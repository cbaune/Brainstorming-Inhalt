\section{»Dinge«, Referenzen und Pointer}


\subsection{»Dinge« und Speicher}

\begin{frame}[fragile]{»Dinge«}
	Das grundlegende Konzept in C++ nennt sich im Standard \enquote{object}. Hinsichtlich Java und Objektorientierung aber missverständlich!
	Wir nennen es daher »Ding«.
	
	\pause
	
	\begin{block}{Standard, 1.8}
		Ein »Ding«
		\begin{enumerate}
			\item ist ein Speicherbereich, aber \emph{keine} Funktion {\tiny(auch wenn diese Speicher belegt!)}.
			\item hat eine Speicherdauer, einen Typen und \emph{kann} einen \emph{Namen} haben.
			\item {\scriptsize hat eine Größe von einem oder mehr Bytes {\tiny (abgesehen von bit-fields)}.}
			\item {\scriptsize von »einfachem« {\tiny (POD)} Typ besetzt eine zusammenhängende Menge Bytes.}
			\item {\scriptsize wird durch eine Definition, den \verb|new|-Ausdruck oder vom Compiler erzeugt.}
		\end{enumerate}
	\end{block}
\end{frame}

\begin{frame}[fragile]{Speicher}
	\begin{block}{Standard, 1.7}
		Die fundamentale Speicher-Einheit im C++ Speichermodell ist das \emph{Byte}. [Es folgt eine sehr abstrakte Definition.]
		Der Speicher, welcher einem C++ Programm zur Verfügung steht, besteht aus einer oder mehreren Sequenzen von zusammenhängenden Bytes.
		Jedes Byte hat eine eindeutige Adresse.
	\end{block}
	
	\pause
	
	\includegraphics[width=\linewidth]{images/free}
\end{frame}

\begin{frame}[fragile]{»Dinge« und Speicher}
	Alle Definitionen legen »Dinge« an.\\
	{\tiny Ausnahme: \verb|static|}
	
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange={3-4, 6-6}]{cpp-code/objects.cpp}
	\end{block}
	}
	
	\pause
	\vspace{1em}
	
	\includegraphics[width=\linewidth]{images/object_things}
\end{frame}


\subsection{Referenzen}

\begin{frame}[fragile]{Referenz: Referenzen}
	\verb|TYPE& add\_name = orig\_name;|
	\begin{itemize}
		\item Führt \verb|add_name| als zusätzlichen Namen für das »Ding« mit dem Namen \verb|orig_name| ein.
		\item \verb|add_name| heißt auch eine Referenz auf \verb|orig_name|.
	\end{itemize}
	
	\vspace{2em}
	
	Achtung: Eine Referenz muss immer gleich »initialisiert« werden, d.h. mittels \verb|=| einem »Ding« zugeordnet. {\tiny Bei Klassen-Membern in der Initialisations-Liste des Konstruktors.}
\end{frame}

\begin{frame}[fragile]{»Dinge« und Referenzen}
	Eine Referenz ist ein zusätzlicher Namen für \emph{dasselbe} »Ding«.\\
	Die Speicherdauer wird dadurch \emph{nicht} beeinflusst.
	
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange=14-15]{cpp-code/objects.cpp}
	\end{block}
	}
	
	\pause
	
	\includegraphics[width=\linewidth]{images/object_refs}
	
	\pause
	
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange=16-17]{cpp-code/objects.cpp}
	\end{block}
	}
\end{frame}

\begin{frame}[fragile]{Referenzen als Parameter}
	Nutzt man eine Referenz als Parameter, so kann man innerhalb der Funktion den Wert des übergebenen »Dings« ändern:
	
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange=34-38]{cpp-code/objects.cpp}
	\end{block}
	}
	
	\pause
	
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange=19-22]{cpp-code/objects.cpp}
	\end{block}
	}
\end{frame}


\subsection{Pointer}

\begin{frame}[fragile]{Adressen und Pointer}
	Jedes Byte hat eine eindeutige Adresse.
	
	Man darf keine Annahmen darüber treffen, wie diese Adresse tatsächlich aussieht oder wie groß sie ist!
	Was man tun darf, sind Operationen mit \emph{Pointern}. Pointer sind Container von Adressen.
	
	\pause
	\vspace{1em}
	
	Wir wollen jedoch zwecks Anschauung eine Adresse mit der Nummer \emph{der} Bytes eines »Dings« identifizieren.
	
	\includegraphics[width=\linewidth]{images/free}
\end{frame}

\begin{frame}[fragile]{»Dinge« und Pointer}
	Sei \verb|NAME| der Name eines »Dings«. Mit \verb|&NAME| erhalte ich dann die Adresse des »Dings«. Die Adresse selbst ist auch wieder ein »Ding«!
	
	\vspace{1em}
	\pause
	
	Als »Ding« hat die Adresse einen Typ:
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange=24-25]{cpp-code/objects.cpp}
	\end{block}
	}
	
	\pause
	
	Das »Ding« \verb|NAME| habe den Typen \verb|TYPE|. Dann hat die Adresse des »Dings« den Typ \verb|TYPE*|.
\end{frame}


\begin{frame}[fragile]{»Dinge«, Pointer und Adressen}
	Ein Beispiel:
	
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange={3-4, 6-6}]{cpp-code/objects.cpp}
	\end{block}
	}
	
	\vspace{1em}
	\phantom{
		\includegraphics[width=\linewidth]{images/object_points_addr}
	}
\end{frame}

	\begin{frame}[fragile]{»Dinge«, Pointer und Adressen}
		Ein Beispiel:
		
		{\footnotesize
		\begin{block}{}
			\lstinputlisting[language=C++, linerange={3-4, 6-6, 10-10}]{cpp-code/objects.cpp}
		\end{block}
		}
		
		\vspace{1em}
		\phantom{
			\includegraphics[width=\linewidth]{images/object_points_addr}
		}
	\end{frame}

	\begin{frame}[fragile]{»Dinge«, Pointer und Adressen}
		Ein Beispiel:
		
		{\footnotesize
		\begin{block}{}
			\lstinputlisting[language=C++, linerange={3-4, 6-6, 10-10, 27-27}]{cpp-code/objects.cpp}
		\end{block}
		}
		
		\pause
		\vspace{1em}
		
		\includegraphics[width=\linewidth]{images/object_points_addr}
	\end{frame}


\begin{frame}[fragile]{Pointer vs. Referenzen}
	\footnotesize
	\begin{tabular}{c|c}
		Pointer & Referenz \\ \hline
		ist ein »Ding« & ist nur ein zusätzlicher Name \\
		enthält eine Adresse & enthält selbst nichts \\
		Inhalt kann sich ändern & bezieht sich immer auf dasselbe »Ding« \\
		Inhalt muss nicht sinnvoll sein & bezieht sich auf ein existierendes »Ding« \\
	\end{tabular}
	
	\pause
	
	{\footnotesize
	\begin{block}{}
		\lstinputlisting[language=C++, linerange={4-4, 27-31}]{cpp-code/objects.cpp}
	\end{block}
	}
\end{frame}
